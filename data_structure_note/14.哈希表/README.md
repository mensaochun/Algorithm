---
typora-copy-images-to: pics
---

# 哈希表

## 1. 哈希表基础

先看一个面试题：

找出一个字符串中第一个只出现过一次的字符。比如leetcoode就是l。

解题思路：将26个字符转为数组索引，出现的次数作为数组的值，构建一个哈希表。然后再遍历数组，进行查表。

~~~c++
class Solution {
public:
    int firstUniqChar(string s) {
        int *freq = new int[26];
        for (int i = 0; i < 26; i++) {
            freq[i] = 0;
        }
        for (int i = 0; i < s.size(); i++) {
            freq[s.at(i) - 'a'] ++;
        }

        for (int i = 0; i < s.size(); ++i) {
            if (freq[s.at(i) - 'a'] == 1) {
                return i;
            }
        }
        return -1;        
    }
};
~~~

哈希表的底层就是利用数组，数组的优势是添加和查找元素的时间复杂度都是O(1)，因此可以利用这个性能。

问题的关键是怎么建立索引，因为键的形式是很多的，比如姓名，身份证号码等等。所以需要找到一个叫做哈希函数的东西，将这些数据映射到索引，然后就可以构建哈希表了。

但是，还有一个问题，就是有可能数据之间会一样？这个时候怎么去解决哈希冲突就是很关键的了。

除此之外，哈希表的思想就是用空间换时间。

## 2. 哈希函数的设计

键通过哈希函数得到的索引分布越均匀越好。

整型：

小整数：容易

负整数：容易

大整数，需要对某一个素数进行取余。素数的选择有专门研究，可以查表。取余的操作是为了让索引的分布更加均匀，但是也可能引入哈希冲突的问题？

浮点数

32位和64位直接看成整数也是可以的。

字符串

可以看成是26进制（一般先取余，在进行进制转换）

复合类型

。。。

## 3. java中hashcode

java中的类才有hashcode，整数实际上也是一个类。

hashcode会计算数据的哈希值。

如果是自己定义的类，需要覆盖hashcode方法。

如果不覆盖，那么对象的地址会作为哈希值。也就是说会默认调用object类中的hashcode方法。

另外，hashcode()映射出来的整数并不一定是正的，可能使负的，因此还不能直接作为索引，需要经过一定的转换。

## 4. 链地址法

**哈希冲突的处理**

哈希表本质就是一个数组。



## 5. 实现属于我们自己的哈希表

哈希冲突的处理

